<!DOCTYPE html>
  <html>
    <head>
      <meta charset="utf-8" />
      <title>Leetcode Playground</title>
    </head>
    <body>
    <h1>Leetcode Playground</h1><h2 class="invalid">invalid problem: algorithms</h2><h2>二进制手表</h2>
<pre>function readBinaryWatch(num) {
  var res = [];
  var a = 0x1111,
    b = 0x111111;
  //   if(time){
  //       res.push(time);
  //   }
  return res;
}</pre>
<ol class="results">
  <li class="not-pass">输入：<code>1</code><br />预期结果：<code>["1:00","2:00","4:00","8:00","0:01","0:02","0:04","0:08","0:16","0:32"]</code><br />输出：<code>[]</code></li>
</ol>
<h2 class="invalid">invalid problem: evaluate-reverse-polish-notation</h2><h2>数组中重复的数据</h2>
<pre>function (nums) {}</pre>
<ol class="results">
  <li class="not-pass">输入：<code>[
  4,
  3,
  2,
  7,
  8,
  2,
  3,
  1
]</code><br />预期结果：<code>[2,3]</code><br />输出：<code>[4,3,2,7,8,2,3,1]</code></li>
</ol>
<h2>01 矩阵</h2>
<pre>function updateMatrix(matrix) {
  var BFS = function (root) {
    var depth = 0;
    var queue = [];
    // const visited = new Set();
    queue.push(root);
    while (queue.length > 0) {
      for (var i = 0, length_1 = queue.length; i < length_1; i++) {
        var _a = queue[0],
          ri = _a[0],
          ci = _a[1];
        if (matrix[ri][ci] === 0) {
          return depth;
        }
        // 上
        if (ri > 0) {
          queue.push([ri - 1, ci]);
        }
        // 下
        if (ri < matrix.length - 1) {
          queue.push([ri + 1, ci]);
        }
        // 左
        if (ci > 0) {
          queue.push([ri, ci - 1]);
        }
        // 右
        if (ci < matrix[ri].length - 1) {
          queue.push([ri, ci + 1]);
        }
        queue.shift();
      }
      depth++;
    }
    return depth;
  };
  var res = [];
  for (var i = 0; i < matrix.length; i++) {
    var row = matrix[i];
    res[i] = res[i] || [];
    for (var j = 0; j < row.length; j++) {
      res[i][j] = BFS([i, j]);
    }
  }
  return res;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  [
    0,
    0,
    0
  ],
  [
    0,
    1,
    0
  ],
  [
    0,
    0,
    0
  ]
]</code><br />预期结果：<code>[[0,0,0],[0,1,0],[0,0,0]]</code><br />输出：<code>[[0,0,0],[0,1,0],[0,0,0]]</code></li>
<li class="pass">输入：<code>[
  [
    0,
    0,
    0
  ],
  [
    0,
    1,
    0
  ],
  [
    1,
    1,
    1
  ]
]</code><br />预期结果：<code>[[0,0,0],[0,1,0],[1,2,1]]</code><br />输出：<code>[[0,0,0],[0,1,0],[1,2,1]]</code></li>
</ol>
<h2>二叉树的中序遍历</h2>
<pre>function inorderTraversal(root) {
  var res = [];
  var stack = [];
  while (root || stack.length > 0) {
    // 只要存在左子树，就一直向下遍历，并压栈
    while (root) {
      stack.push(root);
      root = root.left;
    }
    root = stack.pop();
    res.push(root.val);
    root = root.right;
  }
  return res;
}</pre>
<ol class="results">
  
</ol>
<h2>克隆图</h2>
<pre>function cloneGraph(node) {
  if (node === null) {
    return null;
  }
  var res = new Node(node.val, []);
  var copied = new Map([[res.val, res]]);
  DFS(res, node.neighbors, copied);
  return res;
}</pre>
<ol class="results">
  
</ol>
<h2>外观数列</h2>
<pre>function (n) {
  // 递归
  if (n === 1) {
    return "1";
  }
  return desc(countAndSay(n - 1));
}</pre>
<ol class="results">
  <li class="pass">输入：<code>1</code><br />预期结果：<code>"1"</code><br />输出：<code>"1"</code></li>
<li class="pass">输入：<code>4</code><br />预期结果：<code>"1211"</code><br />输出：<code>"1211"</code></li>
</ol>
<h2>每日温度</h2>
<pre>function dailyTemperatures(T) {
  var stack = [];
  var res = [];
  for (var i = 0; i < T.length; i++) {
    if (stack.length === 0) {
      stack.push(i);
      continue;
    }
    var v = T[i];
    while (T[stack[stack.length - 1]] < v) {
      var idx = stack.pop();
      res[idx] = i - idx;
    }
    stack.push(i);
  }
  while (stack.length) {
    res[stack.pop()] = 0;
  }
  return res;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  73,
  74,
  75,
  71,
  69,
  72,
  76,
  73
]</code><br />预期结果：<code>[1,1,4,2,1,1,0,0]</code><br />输出：<code>[1,1,4,2,1,1,0,0]</code></li>
</ol>
<h2>字符串解码</h2>
<pre>function (s) {
  var sArray = s.split("");
  var stack = [];
  var count = "";
  var string = "";
  while (sArray.length) {
    var el = sArray.shift();
    if (el === "[") {
      if (string) {
        stack.push(string);
        string = "";
      }
      if (count) {
        stack.push(parseInt(count, 10));
        count = "";
      }
      stack.push(el);
    } else if (el === "]") {
      if (string) {
        stack.push(string);
        string = "";
      }
      if (count) {
        stack.push(parseInt(count, 10));
        count = "";
      }
      // 出栈元素，直到遇到数字
      var _a = match(stack),
        n = _a.temp,
        tempStr = _a.tempStr;
      stack.push(tempStr.repeat(n));
    } else if (/\d/.test(el)) {
      if (string) {
        stack.push(string);
        string = "";
      }
      count += el;
    } else {
      if (count) {
        stack.push(parseInt(count, 10));
        count = "";
      }
      string += el;
    }
  }
  return stack.join("") + string;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>"3[a]2[bc]"</code><br />预期结果：<code>"aaabcbc"</code><br />输出：<code>"aaabcbc"</code></li>
<li class="pass">输入：<code>"3[a2[c]]"</code><br />预期结果：<code>"accaccacc"</code><br />输出：<code>"accaccacc"</code></li>
<li class="pass">输入：<code>"2[abc]3[cd]ef"</code><br />预期结果：<code>"abcabccdcdcdef"</code><br />输出：<code>"abcabccdcdcdef"</code></li>
<li class="pass">输入：<code>"abc3[cd]xyz"</code><br />预期结果：<code>"abccdcdcdxyz"</code><br />输出：<code>"abccdcdcdxyz"</code></li>
</ol>
<h2>寻找数组的中心索引</h2>
<pre>function pivotIndex(nums) {
  if (nums.length === 0) return -1;
  if (nums.length === 1) return 0;
  var sum = nums.reduce(function (acc, cur) {
    return acc + cur;
  }, 0);
  var left_sum = 0;
  for (var i = 0; i < nums.length; i++) {
    if (left_sum === (sum - nums[i]) / 2) {
      return i;
    }
    left_sum += nums[i];
  }
  return -1;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  1,
  7,
  3,
  6,
  5,
  6
]</code><br />预期结果：<code>3</code><br />输出：<code>3</code></li>
<li class="pass">输入：<code>[
  1,
  2,
  3
]</code><br />预期结果：<code>-1</code><br />输出：<code>-1</code></li>
</ol>
<h2>字符串中的第一个唯一字符</h2>
<pre>function (s) {
  if (s === "") {
    return -1;
  }
  const hash = {};
  for (let i = 0; i < s.length; i++) {
    if (typeof hash[s.charAt(i)] === "undefined") {
      hash[s.charAt(i)] = [i];
    } else {
      hash[s.charAt(i)].push(i);
    }
  }
  let min = s.length;
  for (const key in hash) {
    if (Object.hasOwnProperty.call(hash, key)) {
      const pos = hash[key];
      if (pos.length === 1 && min > pos[0]) {
        min = pos[0];
      }
    }
  }
  return min === s.length ? -1 : min;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>"leetcode"</code><br />预期结果：<code>0</code><br />输出：<code>0</code></li>
<li class="pass">输入：<code>"loveleetcode"</code><br />预期结果：<code>2</code><br />输出：<code>2</code></li>
</ol>
<h2>图像渲染</h2>
<pre>function floodFill(image, sr, sc, newColor) {
  var originColor = image[sr][sc];
  if (originColor === newColor) {
    return image;
  }
  var queue = [[sr, sc]];
  while (queue.length > 0) {
    var _a = queue.shift(),
      ri = _a[0],
      ci = _a[1];
    if (image[ri][ci] === originColor) {
      image[ri][ci] = newColor;
      // 上
      if (ri > 0 && image[ri - 1][ci] === originColor) {
        queue.push([ri - 1, ci]);
      }
      // 下
      if (ri < image.length - 1 && image[ri + 1][ci] === originColor) {
        queue.push([ri + 1, ci]);
      }
      // 左
      if (ci - 1 >= 0 && image[ri][ci - 1] === originColor) {
        queue.push([ri, ci - 1]);
      }
      // 右
      if (ci + 1 < image[ri].length && image[ri][ci + 1] === originColor) {
        queue.push([ri, ci + 1]);
      }
    }
  }
  return image;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  [
    2,
    2,
    2
  ],
  [
    2,
    2,
    0
  ],
  [
    2,
    0,
    1
  ]
],  1,  1,  2</code><br />预期结果：<code>[[2,2,2],[2,2,0],[2,0,1]]</code><br />输出：<code>[[2,2,2],[2,2,0],[2,0,1]]</code></li>
</ol>
<h2>实现 strStr()</h2>
<pre>function (haystack, needle) {
  // 双指针
  if (needle === "") {
    return 0;
  }
  let i = 0,
    j = 0;
  while (i < haystack.length + 1) {
    if (haystack.charAt(i + j) === needle.charAt(j)) {
      j++;
      if (j === needle.length) {
        return i;
      }
    } else {
      j = 0;
      i++;
    }
  }

  return -1;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>"hello",  "ll"</code><br />预期结果：<code>2</code><br />输出：<code>2</code></li>
<li class="pass">输入：<code>"aaaaa",  "bba"</code><br />预期结果：<code>-1</code><br />输出：<code>-1</code></li>
</ol>
<h2>两个数组的交集 II</h2>
<pre>function (nums1, nums2) {
  let short, long;
  if (nums1.length <= nums2.length) {
    short = nums1;
    long = nums2;
  } else {
    short = nums2;
    long = nums1;
  }
  const hash = {};
  for (const num1 of short) {
    if (typeof hash[num1] === "undefined") {
      hash[num1] = 1;
    } else {
      hash[num1]++;
    }
  }
  const res = [];
  for (const num2 of long) {
    if (hash[num2] && hash[num2] > 0) {
      hash[num2]--;
      res.push(parseInt(num2));
    }
  }
  return res;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  1,
  2,
  2,
  1
],  [
  2,
  2
]</code><br />预期结果：<code>[2,2]</code><br />输出：<code>[2,2]</code></li>
<li class="pass">输入：<code>[
  4,
  9,
  5
],  [
  9,
  4,
  9,
  8,
  4
]</code><br />预期结果：<code>[4,9]</code><br />输出：<code>[4,9]</code></li>
</ol>
<h2>钥匙和房间</h2>
<pre>function canVisitAllRooms(rooms) {
  var res = rooms.map(function (r) {
    return false;
  });
  var stack = [];
  var visited = new Set();
  stack.push(0);
  while (stack.length > 0) {
    for (var i = 0, length_1 = stack.length; i < length_1; i++) {
      var roomIndex = stack.pop();
      visited.add(roomIndex);
      res[roomIndex] = true;
      for (var _i = 0, _a = rooms[roomIndex]; _i < _a.length; _i++) {
        var key = _a[_i];
        if (!visited.has(key)) {
          stack.push(key);
        }
      }
    }
  }
  return res.every(function (r) {
    return r === true;
  });
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  [
    1
  ],
  [
    2
  ],
  [
    3
  ],
  []
]</code><br />预期结果：<code>true</code><br />输出：<code>true</code></li>
<li class="pass">输入：<code>[
  1,
  3
],  [
  3,
  0,
  1
],  [
  2
],  [
  0
]</code><br />预期结果：<code>false</code><br />输出：<code>false</code></li>
</ol>
<h2>拥有最多糖果的孩子</h2>
<pre>function (candies, extraCandies) {
  var max = candies.reduce(function (prev, curr) {
    return prev > curr ? prev : curr;
  }, 0);
  return candies.map(function (c) {
    return max - c <= extraCandies;
  });
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  2,
  3,
  5,
  1,
  3
],  3</code><br />预期结果：<code>[true,true,true,false,true]</code><br />输出：<code>[true,true,true,false,true]</code></li>
<li class="pass">输入：<code>[
  4,
  2,
  1,
  1,
  2
],  1</code><br />预期结果：<code>[true,false,false,false,false]</code><br />输出：<code>[true,false,false,false,false]</code></li>
<li class="pass">输入：<code>[
  12,
  1,
  12
],  10</code><br />预期结果：<code>[true,false,true]</code><br />输出：<code>[true,false,true]</code></li>
</ol>
<h2>合并区间</h2>
<pre>function merge(intervals) {
  intervals.sort(function (a, b) {
    return a[0] - b[0];
  });
  var res = [];
  for (var _i = 0, intervals_1 = intervals; _i < intervals_1.length; _i++) {
    var intv = intervals_1[_i];
    if (res.length === 0) {
      res.push(intv);
    } else {
      var top_1 = res[res.length - 1];
      if (intv[0] > top_1[1]) {
        res.push(intv);
      } else {
        top_1[1] = top_1[1] < intv[1] ? intv[1] : top_1[1];
      }
    }
  }
  return res;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  [
    1,
    6
  ],
  [
    2,
    6
  ],
  [
    8,
    10
  ],
  [
    15,
    18
  ]
]</code><br />预期结果：<code>[[1,6],[8,10],[15,18]]</code><br />输出：<code>[[1,6],[8,10],[15,18]]</code></li>
<li class="pass">输入：<code>[
  [
    1,
    5
  ],
  [
    4,
    5
  ]
]</code><br />预期结果：<code>[[1,5]]</code><br />输出：<code>[[1,5]]</code></li>
</ol>
<h2>最小栈</h2>
<pre>function MinStack() {
  this.stack = [];
}</pre>
<ol class="results">
  
</ol>
<h2>移动零</h2>
<pre>function (nums) {
  let count = 0;
  let i = 0;
  while (i < nums.length - count) {
    const num = nums[i];
    if (num === 0) {
      count++;
      nums.push(nums.splice(i, 1)[0]);
    } else {
      i++;
    }
  }
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  1,
  3,
  12,
  0,
  0
]</code><br />预期结果：<code>[1,3,12,0,0]</code><br />输出：<code>[1,3,12,0,0]</code></li>
</ol>
<h2>岛屿数量</h2>
<pre>function numIslands(grid) {
  var res = 0;
  var DFS = function (_a) {
    var y = _a[0],
      x = _a[1];
    grid[y][x] = "0";
    // 上
    if (y > 0 && grid[y - 1][x] === "1") {
      DFS([y - 1, x]);
    }
    // 下
    if (y < grid.length - 1 && grid[y + 1][x] === "1") {
      DFS([y + 1, x]);
    }
    // 左
    if (x > 0 && grid[y][x - 1] === "1") {
      DFS([y, x - 1]);
    }
    // 右
    if (x < grid[y].length - 1 && grid[y][x + 1] === "1") {
      DFS([y, x + 1]);
    }
  };
  for (var y = 0; y < grid.length; y++) {
    //   y: 列序号
    var col = grid[y];
    for (var x = 0; x < col.length; x++) {
      // x: 行序号
      var el = col[x];
      if (el === "1") {
        res++;
        DFS([y, x]);
      }
    }
  }
  return res;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  [
    "0",
    "0",
    "0",
    "0",
    "0"
  ],
  [
    "0",
    "0",
    "0",
    "0",
    "0"
  ],
  [
    "0",
    "0",
    "0",
    "0",
    "0"
  ],
  [
    "0",
    "0",
    "0",
    "0",
    "0"
  ]
]</code><br />预期结果：<code>1</code><br />输出：<code>1</code></li>
<li class="pass">输入：<code>[
  [
    "0",
    "0",
    "0",
    "0",
    "0"
  ],
  [
    "0",
    "0",
    "0",
    "0",
    "0"
  ],
  [
    "0",
    "0",
    "0",
    "0",
    "0"
  ],
  [
    "0",
    "0",
    "0",
    "0",
    "0"
  ]
]</code><br />预期结果：<code>3</code><br />输出：<code>3</code></li>
</ol>
<h2>打开转盘锁</h2>
<pre>function openLock(deadends, target) {
  var tried = new Set();
  var queue = [];
  var depth = 0;
  queue.push("0000");
  var prevMap = {
      0: "9",
      1: "0",
      2: "1",
      3: "2",
      4: "3",
      5: "4",
      6: "5",
      7: "6",
      8: "7",
      9: "8",
    },
    nextMap = {
      0: "1",
      1: "2",
      2: "3",
      3: "4",
      4: "5",
      5: "6",
      6: "7",
      7: "8",
      8: "9",
      9: "0",
    };
  while (queue.length > 0) {
    for (var i = 0, length_1 = queue.length; i < length_1; i++) {
      var code = queue[0];
      if (code === target) {
        return depth;
      }
      if (deadends.indexOf(code) < 0 && !tried.has(code)) {
        // 未锁定，未试
        tried.add(code);
        // 计算当前密码相邻的8种密码
        var bits = code.split("");
        for (var i_1 = 0; i_1 < bits.length; i_1++) {
          var bit = bits[i_1];
          var bits_copy = JSON.parse(JSON.stringify(bits));
          bits_copy[i_1] = prevMap[bit];
          queue.push(bits_copy.join(""));
          bits_copy[i_1] = nextMap[bit];
          queue.push(bits_copy.join(""));
        }
      }
      queue.shift();
    }
    depth++;
  }
  return -1;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  "0201",
  "0101",
  "0102",
  "1212",
  "2002"
],  "0202"</code><br />预期结果：<code>6</code><br />输出：<code>6</code></li>
<li class="pass">输入：<code>[
  "8888"
],  "0009"</code><br />预期结果：<code>1</code><br />输出：<code>1</code></li>
<li class="pass">输入：<code>[
  "8887",
  "8889",
  "8878",
  "8898",
  "8788",
  "8988",
  "7888",
  "9888"
],  "8888"</code><br />预期结果：<code>-1</code><br />输出：<code>-1</code></li>
<li class="pass">输入：<code>[
  "0000"
],  "8888"</code><br />预期结果：<code>-1</code><br />输出：<code>-1</code></li>
</ol>
<h2>完全平方数</h2>
<pre>function numSquares(n) {
  var e_1, _a;
  var queue = [n];
  var level = 0;
  var squares = [];
  var i = 1;
  while (i * i <= n) {
    squares.push(i * i);
    i++;
  }
  while (queue.length > 0) {
    var nextLevel = new Set();
    level++;
    try {
      for (
        var queue_1 = __values(queue), queue_1_1 = queue_1.next();
        !queue_1_1.done;
        queue_1_1 = queue_1.next()
      ) {
        var m = queue_1_1.value;
        for (var k = squares.length - 1; k >= 0; k--) {
          var squareNum = squares[k];
          if (squareNum === m) {
            return level;
          } else if (squareNum > m) {
            continue;
          } else {
            nextLevel.add(m - squareNum);
          }
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (queue_1_1 && !queue_1_1.done && (_a = queue_1.return))
          _a.call(queue_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    queue = Array.from(nextLevel.values());
  }
  return -1;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>12</code><br />预期结果：<code>3</code><br />输出：<code>3</code></li>
<li class="pass">输入：<code>13</code><br />预期结果：<code>2</code><br />输出：<code>2</code></li>
</ol>
<h2>加一</h2>
<pre>function (digits) {
  const res = [...digits];
  let index = res.length - 1;
  res[index]++;
  while (res[index] === 10) {
    res[index] = 0;
    index--;
    if (index === -1) {
      res.unshift(1);
      break;
    } else {
      res[index]++;
    }
  }
  return res;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  1,
  2,
  3
]</code><br />预期结果：<code>[1,2,4]</code><br />输出：<code>[1,2,4]</code></li>
<li class="pass">输入：<code>[
  4,
  3,
  2,
  1
]</code><br />预期结果：<code>[4,3,2,2]</code><br />输出：<code>[4,3,2,2]</code></li>
<li class="pass">输入：<code>[
  0
]</code><br />预期结果：<code>[1]</code><br />输出：<code>[1]</code></li>
<li class="pass">输入：<code>[
  9
]</code><br />预期结果：<code>[1,0]</code><br />输出：<code>[1,0]</code></li>
</ol>
<h2>整数反转</h2>
<pre>function (x) {
  if (x === 0) {
    return 0;
  }
  let stack;
  const res = [];
  x = x.toString();
  if (x.startsWith("-")) {
    stack = x.substr(1).split("");
    stack.push("-");
  } else {
    stack = x.split("");
  }
  while (stack.length) {
    const num = stack.pop();
    if (res.length === 0 && num === "0") {
      continue;
    } else {
      res.push(num);
    }
    if (
      parseInt(res.join("")) > Math.pow(2, 31) - 1 ||
      parseInt(res.join("")) < -Math.pow(2, 31)
    ) {
      return 0;
    }
  }
  return parseInt(res.join(""));
}</pre>
<ol class="results">
  <li class="pass">输入：<code>123</code><br />预期结果：<code>321</code><br />输出：<code>321</code></li>
<li class="pass">输入：<code>-123</code><br />预期结果：<code>-321</code><br />输出：<code>-321</code></li>
<li class="pass">输入：<code>120</code><br />预期结果：<code>21</code><br />输出：<code>21</code></li>
</ol>
<h2>反转字符串</h2>
<pre>function (s) {
  for (let i = 0; i < s.length / 2; i++) {
    const temp = s[i];
    s[i] = s[s.length - 1 - i];
    s[s.length - 1 - i] = temp;
  }
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  "o",
  "l",
  "l",
  "e",
  "h"
]</code><br />预期结果：<code>["o","l","l","e","h"]</code><br />输出：<code>["o","l","l","e","h"]</code></li>
<li class="pass">输入：<code>[
  "h",
  "a",
  "n",
  "n",
  "a",
  "H"
]</code><br />预期结果：<code>["h","a","n","n","a","H"]</code><br />输出：<code>["h","a","n","n","a","H"]</code></li>
</ol>
<h2>旋转图像</h2>
<pre>function (matrix) {
  const n = matrix.length;
  // x轴翻转
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n / 2; j++) {
      const temp = matrix[j][i];
      matrix[j][i] = matrix[n - 1 - j][i];
      matrix[n - 1 - j][i] = temp;
    }
  }
  // 主对角线翻转
  for (let i = 1; i < n; i++) {
    for (let j = 0; j < i; j++) {
      const temp = matrix[i][j];
      matrix[i][j] = matrix[j][i];
      matrix[j][i] = temp;
    }
  }
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  [
    7,
    4,
    1
  ],
  [
    8,
    5,
    2
  ],
  [
    9,
    6,
    3
  ]
]</code><br />预期结果：<code>[[7,4,1],[8,5,2],[9,6,3]]</code><br />输出：<code>[[7,4,1],[8,5,2],[9,6,3]]</code></li>
<li class="pass">输入：<code>[
  [
    15,
    13,
    2,
    5
  ],
  [
    14,
    3,
    4,
    1
  ],
  [
    12,
    6,
    8,
    9
  ],
  [
    16,
    7,
    10,
    11
  ]
]</code><br />预期结果：<code>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</code><br />输出：<code>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</code></li>
</ol>
<h2>旋转矩阵</h2>
<pre>function rotate(matrix) {
  // LC解答： 先水平中线反转，再主对角线翻转
  var n = matrix.length;
  //   上下翻转
  for (var ri = 0; ri < Math.floor(n / 2); ri++) {
    var tempRow = matrix[ri];
    matrix[ri] = matrix[n - 1 - ri];
    matrix[n - 1 - ri] = tempRow;
  }
  //   主对角线翻转
  for (var ri = 0; ri < n; ri++) {
    for (var ci = 0; ci < ri; ci++) {
      var temp = matrix[ri][ci];
      matrix[ri][ci] = matrix[ci][ri];
      matrix[ci][ri] = temp;
    }
  }
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  [
    7,
    4,
    1
  ],
  [
    8,
    5,
    2
  ],
  [
    9,
    6,
    3
  ]
]</code><br />预期结果：<code>[[7,4,1],[8,5,2],[9,6,3]]</code><br />输出：<code>[[7,4,1],[8,5,2],[9,6,3]]</code></li>
<li class="pass">输入：<code>[
  [
    15,
    13,
    2,
    5
  ],
  [
    14,
    3,
    4,
    1
  ],
  [
    12,
    6,
    8,
    9
  ],
  [
    16,
    7,
    10,
    11
  ]
]</code><br />预期结果：<code>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</code><br />输出：<code>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</code></li>
</ol>
<h2>搜索插入位置</h2>
<pre>function searchInsert(nums, target) {
  var left = 0,
    right = nums.length - 1;
  while (left <= right) {
    var mid = left + Math.floor((right - left) / 2);
    if (nums[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  1,
  3,
  5,
  6
],  5</code><br />预期结果：<code>2</code><br />输出：<code>2</code></li>
<li class="pass">输入：<code>[
  1,
  3,
  5,
  6
],  2</code><br />预期结果：<code>1</code><br />输出：<code>1</code></li>
<li class="pass">输入：<code>[
  1,
  3,
  5,
  6
],  7</code><br />预期结果：<code>4</code><br />输出：<code>4</code></li>
<li class="pass">输入：<code>[
  1,
  3,
  5,
  6
],  0</code><br />预期结果：<code>0</code><br />输出：<code>0</code></li>
</ol>
<h2>只出现一次的数字</h2>
<pre>function singleNumber(nums) {
  nums.sort((a, b) => a - b);
  if (nums.length === 1) {
    return nums[0];
  }
  if (nums.length === 3) {
    return nums[0] === nums[1] ? nums[2] : nums[0];
  }
  for (let i = 1; i < nums.length - 2; i++) {
    if (nums[i] > nums[i - 1] && nums[i] < nums[i + 1]) {
      return nums[i];
    }
  }
  return nums[0] === nums[1] ? nums[nums.length - 1] : nums[0];
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  1,
  2,
  2
]</code><br />预期结果：<code>1</code><br />输出：<code>1</code></li>
<li class="pass">输入：<code>[
  1,
  1,
  2,
  2,
  4
]</code><br />预期结果：<code>4</code><br />输出：<code>4</code></li>
</ol>
<h2>字符串转换整数 (atoi)</h2>
<pre>function (s) {
  //   s = s.replace(/^\s*/, "");
  //   if (s === "") {
  //     // 字符串为空或字符串仅包含空白字符
  //     return 0;
  //   }
  //   const reg = /^(\+[0-9]|-[0-9]|[0-9])[0-9]*/;
  //   const num = reg.exec(s);
  //   if (num) {
  //     const res = parseInt(num[0]);
  //     if (res > Math.pow(2, 31) - 1) {
  //       return Math.pow(2, 31) - 1;
  //     } else if (res < -Math.pow(2, 31)) {
  //       return -Math.pow(2, 31);
  //     }
  //     return res;
  //   }
  //   return 0;

  // 自动机解法
  const auto = new Automaton();
  for (let i = 0; i < s.length; i++) {
    auto.get(s.charAt(i));
  }
  return auto.negative ? -auto.ans : auto.ans;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>"42"</code><br />预期结果：<code>42</code><br />输出：<code>42</code></li>
<li class="pass">输入：<code>"   -42"</code><br />预期结果：<code>-42</code><br />输出：<code>-42</code></li>
<li class="pass">输入：<code>"4193 with words"</code><br />预期结果：<code>4193</code><br />输出：<code>4193</code></li>
<li class="pass">输入：<code>"words and 987"</code><br />预期结果：<code>0</code><br />输出：<code>0</code></li>
<li class="pass">输入：<code>"-91283472332"</code><br />预期结果：<code>-2147483648</code><br />输出：<code>-2147483648</code></li>
</ol>
<h2>目标和</h2>
<pre>function findTargetSumWays(nums, S) {
  var res = 0;
  var DFS = function (acc, rest) {
    if (rest.length > 0) {
      var num = rest[0];
      var _num = -num;
      var next = rest.slice(1);
      DFS(acc + num, next);
      DFS(acc + _num, next);
    } else {
      if (acc === S) {
        res++;
      }
    }
  };
  DFS(0, nums);
  return res;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  1,
  1,
  1,
  1,
  1
],  3</code><br />预期结果：<code>5</code><br />输出：<code>5</code></li>
</ol>
<h2>两数之和</h2>
<pre>function (nums, target) {
  const hash = {};
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i];
    if (typeof hash[target - num] !== "undefined") {
      return [hash[target - num], i];
    }
    hash[num] = i;
  }
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  2,
  7,
  11,
  15
],  9</code><br />预期结果：<code>[0,1]</code><br />输出：<code>[0,1]</code></li>
<li class="pass">输入：<code>[
  3,
  3
],  6</code><br />预期结果：<code>[0,1]</code><br />输出：<code>[0,1]</code></li>
<li class="pass">输入：<code>[
  3,
  2,
  3
],  6</code><br />预期结果：<code>[0,2]</code><br />输出：<code>[0,2]</code></li>
</ol>
<h2>验证回文串</h2>
<pre>function (s) {
  s = s
    .split("")
    .filter((char) => /[a-z0-9A-Z]/.test(char))
    .map((char) => char.toLowerCase());
  for (let i = 0; i < s.length / 2; i++) {
    if (s[i] !== s[s.length - 1 - i]) {
      return false;
    }
  }
  return true;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>"A man, a plan, a canal: Panama"</code><br />预期结果：<code>true</code><br />输出：<code>true</code></li>
<li class="pass">输入：<code>"race a car"</code><br />预期结果：<code>false</code><br />输出：<code>false</code></li>
</ol>
<h2>有效的括号</h2>
<pre>function isValid(s) {
  var e_1, _a;
  var chars = s.split("");
  var stack = [];
  try {
    for (
      var chars_1 = __values(chars), chars_1_1 = chars_1.next();
      !chars_1_1.done;
      chars_1_1 = chars_1.next()
    ) {
      var char = chars_1_1.value;
      switch (char) {
        case ")":
          if (stack.pop() !== "(") {
            return false;
          }
          break;
        case "}":
          if (stack.pop() !== "{") {
            return false;
          }
          break;
        case "]":
          if (stack.pop() !== "[") {
            return false;
          }
          break;
        default:
          stack.push(char);
          break;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (chars_1_1 && !chars_1_1.done && (_a = chars_1.return))
        _a.call(chars_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return stack.length === 0;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>"()"</code><br />预期结果：<code>true</code><br />输出：<code>true</code></li>
<li class="pass">输入：<code>"()[]{}"</code><br />预期结果：<code>true</code><br />输出：<code>true</code></li>
<li class="pass">输入：<code>"(]"</code><br />预期结果：<code>false</code><br />输出：<code>false</code></li>
<li class="pass">输入：<code>"([)]"</code><br />预期结果：<code>false</code><br />输出：<code>false</code></li>
<li class="pass">输入：<code>"{[]}"</code><br />预期结果：<code>true</code><br />输出：<code>true</code></li>
</ol>
<h2>有效的数独</h2>
<pre>function (board) {
  //   暴力解法
  // 行
  // let hash;
  // for (let i = 0; i < 9; i++) {
  //   hash = {};
  //   for (let j = 0; j < 9; j++) {
  //     const num = board[i][j];
  //     if (num === ".") continue;
  //     if (hash[num]) {
  //       return false;
  //     }
  //     hash[num] = true;
  //   }
  // }
  // // 列
  // for (let i = 0; i < 9; i++) {
  //   hash = {};
  //   for (let j = 0; j < 9; j++) {
  //     const num = board[j][i];
  //     if (num === ".") continue;
  //     if (hash[num]) {
  //       return false;
  //     }
  //     hash[num] = true;
  //   }
  // }
  // // 3x3宫
  // for (let i = 0; i < 3; i++) {
  //   for (let j = 0; j < 3; j++) {
  //     hash = {};
  //     for (let k = i * 3; k < i * 3 + 3; k++) {
  //       for (let v = j * 3; v < j * 3 + 3; v++) {
  //         const num = board[k][v];
  //         if (num === ".") continue;
  //         if (hash[num]) {
  //           return false;
  //         }
  //         hash[num] = true;
  //       }
  //     }
  //   }
  // }
  // return true;

  // 一次迭代
  const rows = [],
    columns = [];
  subBoards = [];
  for (let i = 0; i < 9; i++) {
    for (let j = 0; j < 9; j++) {
      const num = board[i][j];
      if (num === ".") {
        continue;
      }
      // 行
      if (rows[i]) {
        if (rows[i][num] === true) {
          return false;
        } else {
          rows[i][num] = true;
        }
      } else {
        rows[i] = { [num]: true };
      }
      // 列
      if (columns[j]) {
        if (columns[j][num] === true) {
          return false;
        } else {
          columns[j][num] = true;
        }
      } else {
        columns[j] = { [num]: true };
      }
      // 宫
      if (subBoards[Math.floor(i / 3) * 3 + Math.floor(j / 3)]) {
        if (
          subBoards[Math.floor(i / 3) * 3 + Math.floor(j / 3)][num] === true
        ) {
          return false;
        } else {
          subBoards[Math.floor(i / 3) * 3 + Math.floor(j / 3)][num] = true;
        }
      } else {
        subBoards[Math.floor(i / 3) * 3 + Math.floor(j / 3)] = { [num]: true };
      }
    }
  }
  return true;
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  [
    "5",
    "3",
    ".",
    ".",
    "7",
    ".",
    ".",
    ".",
    "."
  ],
  [
    "6",
    ".",
    ".",
    "1",
    "9",
    "5",
    ".",
    ".",
    "."
  ],
  [
    ".",
    "9",
    "8",
    ".",
    ".",
    ".",
    ".",
    "6",
    "."
  ],
  [
    "8",
    ".",
    ".",
    ".",
    "6",
    ".",
    ".",
    ".",
    "3"
  ],
  [
    "4",
    ".",
    ".",
    "8",
    ".",
    "3",
    ".",
    ".",
    "1"
  ],
  [
    "7",
    ".",
    ".",
    ".",
    "2",
    ".",
    ".",
    ".",
    "6"
  ],
  [
    ".",
    "6",
    ".",
    ".",
    ".",
    ".",
    "2",
    "8",
    "."
  ],
  [
    ".",
    ".",
    ".",
    "4",
    "1",
    "9",
    ".",
    ".",
    "5"
  ],
  [
    ".",
    ".",
    ".",
    ".",
    "8",
    ".",
    ".",
    "7",
    "9"
  ]
]</code><br />预期结果：<code>true</code><br />输出：<code>true</code></li>
<li class="pass">输入：<code>[
  [
    "8",
    "3",
    ".",
    ".",
    "7",
    ".",
    ".",
    ".",
    "."
  ],
  [
    "6",
    ".",
    ".",
    "1",
    "9",
    "5",
    ".",
    ".",
    "."
  ],
  [
    ".",
    "9",
    "8",
    ".",
    ".",
    ".",
    ".",
    "6",
    "."
  ],
  [
    "8",
    ".",
    ".",
    ".",
    "6",
    ".",
    ".",
    ".",
    "3"
  ],
  [
    "4",
    ".",
    ".",
    "8",
    ".",
    "3",
    ".",
    ".",
    "1"
  ],
  [
    "7",
    ".",
    ".",
    ".",
    "2",
    ".",
    ".",
    ".",
    "6"
  ],
  [
    ".",
    "6",
    ".",
    ".",
    ".",
    ".",
    "2",
    "8",
    "."
  ],
  [
    ".",
    ".",
    ".",
    "4",
    "1",
    "9",
    ".",
    ".",
    "5"
  ],
  [
    ".",
    ".",
    ".",
    ".",
    "8",
    ".",
    ".",
    "7",
    "9"
  ]
]</code><br />预期结果：<code>false</code><br />输出：<code>false</code></li>
</ol>
<h2>零矩阵</h2>
<pre>function setZeroes(matrix) {
  var zeros = [];
  for (var ri = 0; ri < matrix.length; ri++) {
    var row = matrix[ri];
    for (var ci = 0; ci < row.length; ci++) {
      var el = row[ci];
      if (el === 0) {
        zeros.push([ri, ci]);
      }
    }
  }
  for (var _i = 0, zeros_1 = zeros; _i < zeros_1.length; _i++) {
    var _a = zeros_1[_i],
      ri = _a[0],
      ci = _a[1];
    //   行不变
    for (var i = 0; i < matrix[ri].length; i++) {
      matrix[ri][i] = 0;
    }
    // 列不变
    for (var i = 0; i < matrix.length; i++) {
      matrix[i][ci] = 0;
    }
  }
}</pre>
<ol class="results">
  <li class="pass">输入：<code>[
  [
    1,
    0,
    1
  ],
  [
    0,
    0,
    0
  ],
  [
    1,
    0,
    1
  ]
]</code><br />预期结果：<code>[[1,0,1],[0,0,0],[1,0,1]]</code><br />输出：<code>[[1,0,1],[0,0,0],[1,0,1]]</code></li>
<li class="pass">输入：<code>[
  [
    0,
    0,
    0,
    0
  ],
  [
    0,
    4,
    5,
    0
  ],
  [
    0,
    3,
    1,
    0
  ]
]</code><br />预期结果：<code>[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</code><br />输出：<code>[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</code></li>
</ol>
<script src="venders.main.63e212db3ec9f25c269c.js"></script><script src="main.c5ad826503c71b3e95db.js"></script></body>
    </html>
    